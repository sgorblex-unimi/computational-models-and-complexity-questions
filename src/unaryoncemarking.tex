\chapter{Unary once-marking \texorpdfstring{$1$}{1}-limited automata}
Unary languages are languages over a one-letter alphabet.
In formal language theory, they have been studied extensively, one of the main reasons being that, in the unary case, the classes of context-free and regular languages coincide \cite{GinRic62}.
The descriptional complexity of the unary case has been thoroughly investigated over the years.
Because of the equality of the two classes, many computational models are equivalent: typical regular language acceptors such as one- and two-way finite state automata as well as typical context-free models such as pushdown automata and context-free grammars.
The relative succinctness of these models has been inspected by building simulations and studying lower bounds (see, \eg[,] \cite{GefMer+03,MerPig01,Pig08,PigSha+02}).
At the same time, many bounds have been proven on the descriptional complexity of operations on unary languages (see, \eg[,] \cite{HolKut03,KunOkh12,MerPig05,PigSha02}).
Another reason why the unary case is studied extensively is that proving the Sakoda and Sipser conjecture, even in the unary case, would prove the separation of the space complexity classes $\cL$ and $\cNL$ (see \Cref{sec:context-descrcomp}).

Once-marking $1$-limited automata consist in machines with a single tape, delimited by end-markers ($\lem$,$\rem$), that can only write a single time on the first visit of a tape cell.
They have been introduced and studied by \citeauthor{PigPri23a}, who proved a double exponential tight bound for the simulation by \ODFAs in the general case and a polynomial one with \TDFA in the deterministic case.

In this chapter, we revise the previous work on once-marking $1$-limited automata, proving a previously mistaken bound on the simulation by \NFA (\Cref{sec:oncemarking-general}).
We then gather previous results in order to obtain a map of the costs in the unary case (\Cref{sec:oncemarking-unary}).
Finally, we discuss ideas to potentially improve these bounds, by applying to this model techniques form different variants of regular languages and their recognizers (\Cref{sec:oncemarking-ideas}).



\section{The general case}\label{sec:oncemarking-general}
Once-marking $1$-limited automata (\OMOLA) are a restriction of $1$-limited automata (see \Cref{def:kla}) that can only mark a single tape cell throughout the entire computation.

In the seminal paper, \citeauthor{PigPri23a} show that in the general case there is a double exponential tight bound for the simulation of a \OMOLA by a \ODFA \cite{PigPri23a}.
In particular, the upper bound is inherited from the simulation of \OLA, while a new lower bound is proven with a restricted case of \OMOLA that is also sweeping and can only use nondeterminism in the first visit to tape cells.
Regarding fully deterministic once-marking $1$-limited automata (\OMODLA), the authors build a construction based on the simulation of the machine's computation tree by a \TDFA, which only requires a cubic size increase.

\begin{table}
	\centering
	\input{tables/sims-om-general}%
	\caption{Costs of the simulations between once-marking $1$-limited automata and other regular language acceptors, general case.}
	\label{tab:sims-om-general-oncemarking}
\end{table}

We summarize these and other related results in \Cref{tab:sims-om-general-oncemarking}.
We point out that the simulation of \OMODLA by \ONFA has been mistakenly labeled as polynomial in \cite{PigPri23a}, while there is indeed an exponential lower bound:
\begin{thrm}
	For each integer $n$ there exists an $n$-state \OMODLA $A$ such that every \ONFA recognizing $\genlang(A)$ requires an exponential number of states in $n$.
\end{thrm}
\begin{proof}
	\newcommand{\double}{\mathrm{DOUBLE}_n}
	Consider the language $\double:=\set{ww\mid w\in\set{a,b}^n}$.
	A \OMODLA can recognize $\double$ as follows:
	\begin{enumerate}
		\item By using an $n$-state counter, the automaton marks the $(n+1)$-th input cell (if there is no such cell, it rejects).
		\item The tape head is reset to the first input symbol by first reaching the left end-marker and then moving right once. The scanned symbol is saved in the finite state memory.
		\item\label{itm:double-step3} By moving $n$ times to the right, the head is brought to the first symbol in the second "half" of the input. The scanned symbol is compared to the one saved.
		      If they are different, the machine rejects.
		\item\label{itm:double-step4} By moving $n$ times to the left followed by one to the right (or simply $n-1$ times to the left), the head is brought to the second symbol in the first half of the input. The scanned symbol is saved.
		\item Steps \ref{itm:double-step3} to \ref{itm:double-step4} are repeated until, after the single move to the right in step \ref{itm:double-step4}, the head scans the marked cell. When this happens, the comparison of the two halves has been completed.
		\item The machine performs $n$ steps to the right and, provided the scanned cell is $\rem$, accepts by moving to the right once more.
		      Otherwise, the input string is longer than $2n$, therefore the machine must reject.
	\end{enumerate}
	The resulting automaton, which only uses a counter up to $n$ and saves a symbol in $\set{a,b}$, has a linear number of states in $n$.

	We now prove that every \ONFA needs an exponential number of states to accept $\double$.
	In order to do so, we use a standard technique known as \emph{fooling set} \cite{Bir92}.
	Given a language $L$, a fooling set is a set of pairs of strings $\set{(x_i,y_i)}$ such that
	\begin{itemize}
		\item for all $i$, $x_iy_i\in L$, and
		\item for all $i\ne j$, $x_iy_j\notin L$ and $x_jy_i\notin L$.
	\end{itemize}
	The cardinality of each fooling set is a lower bound for the number of states of every \ONFA accepting $L$.

	Consider the set $S:=\set{(w_i,w_i)\mid w_i\in\set{a,b}^n}$.
	Obviously, $w_iw_i\in\double$ for all $i$.
	Furthermore, if $i\ne j$, $w_iw_j$ and $w_jw_i$ do not belong to $\double$, as the two halves of each word are different.
	Since $\card S=2^n$, every \ONFA accepting $\double$ has at least $2^n$ states.

	Finally, we point out that, by replacing the marked cell with a simple check that the input length is $2n$, the language $\double$ can be accepted by a simple \TDFA with a slightly greater number of states.
	Indeed, since \TDFA can be considered a special case of \OMODLA, the exponential cost of their simulation by \ONFA can be simply considered a consequence of the one of \TDFA by \ONFA.
\end{proof}



\section{The unary case}\label{sec:oncemarking-unary}



\section{Improving known bounds}\label{sec:oncemarking-ideas}
